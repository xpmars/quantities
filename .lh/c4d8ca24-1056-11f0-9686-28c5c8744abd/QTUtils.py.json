{
    "sourceFile": "c4d8ca24-1056-11f0-9686-28c5c8744abd/QTUtils.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1744185176721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1744247464224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,7 +173,31 @@\n     MACD = (DIF - DEA) * 2\r\n     return DIF, DEA, MACD\r\n \r\n \r\n+def calculate_dynamic_position(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    hist = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high, low, close = hist['high'], hist['low'], hist['close']\r\n+    tr = np.maximum(high[-1]-low[-1], \r\n+                   np.maximum(abs(high[-1]-close[-2]), \r\n+                             abs(low[-1]-close[-2])))\r\n+    atr = np.mean(tr[-context.atr_period:])\r\n+    \r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    \r\n+    # 计算动态仓位\r\n+    position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n+    current_price = close[-1]\r\n+    return int(position_value / current_price / 100) * 100  # 整手数\r\n+\r\n+    # 修改on_bar中的交易量计算\r\n+    trade_value = min(available_cash * context.trade_cash_ratio,\r\n+                    calculate_dynamic_position(context, symbol) * current_price)\r\n+\r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744247735153,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,11 +193,8 @@\n     position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n     current_price = close[-1]\r\n     return int(position_value / current_price / 100) * 100  # 整手数\r\n \r\n-    # 修改on_bar中的交易量计算\r\n-    trade_value = min(available_cash * context.trade_cash_ratio,\r\n-                    calculate_dynamic_position(context, symbol) * current_price)\r\n \r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744247945650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,16 +176,26 @@\n \r\n def calculate_dynamic_position(context, symbol):\r\n     \"\"\"动态仓位计算函数\"\"\"\r\n     # 获取ATR波动率\r\n-    hist = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n                        fields='high,low,close')\r\n-    high, low, close = hist['high'], hist['low'], hist['close']\r\n-    tr = np.maximum(high[-1]-low[-1], \r\n-                   np.maximum(abs(high[-1]-close[-2]), \r\n-                             abs(low[-1]-close[-2])))\r\n-    atr = np.mean(tr[-context.atr_period:])\r\n+    high = data['high'].values\r\n+    low = data['low'].values\r\n+    close = data['close'].values\r\n     \r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    # 计算ATR（简单移动平均）\r\n+    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n+    \r\n     # 获取账户风险预算\r\n     account = context.account()\r\n     risk_budget = account.cash['nav'] * context.risk_ratio\r\n     \r\n"
                },
                {
                    "date": 1744247962426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,10 @@\n     MACD = (DIF - DEA) * 2\r\n     return DIF, DEA, MACD\r\n \r\n \r\n-def calculate_dynamic_position(context, symbol):\r\n+    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n+def calculate_dynamic_position(context, symbol， ):\r\n     \"\"\"动态仓位计算函数\"\"\"\r\n     # 获取ATR波动率\r\n     data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n                        fields='high,low,close')\r\n"
                },
                {
                    "date": 1744247971790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,10 +173,9 @@\n     MACD = (DIF - DEA) * 2\r\n     return DIF, DEA, MACD\r\n \r\n \r\n-    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n-def calculate_dynamic_position(context, symbol， ):\r\n+def calculate_dynamic_position(context, symbol, period):\r\n     \"\"\"动态仓位计算函数\"\"\"\r\n     # 获取ATR波动率\r\n     data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n                        fields='high,low,close')\r\n"
                },
                {
                    "date": 1744248029066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,9 @@\n     MACD = (DIF - DEA) * 2\r\n     return DIF, DEA, MACD\r\n \r\n \r\n-def calculate_dynamic_position(context, symbol, period):\r\n+def calculate_dynamic_position(context, symbol):\r\n     \"\"\"动态仓位计算函数\"\"\"\r\n     # 获取ATR波动率\r\n     data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n                        fields='high,low,close')\r\n@@ -192,9 +192,9 @@\n             abs(low[i] - close[i-1])\r\n         )\r\n     \r\n     # 计算ATR（简单移动平均）\r\n-    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n+    atr = np.convolve(tr, np.ones(context.atr_period)/context.atr_period, mode='valid')\r\n     \r\n     # 获取账户风险预算\r\n     account = context.account()\r\n     risk_budget = account.cash['nav'] * context.risk_ratio\r\n"
                },
                {
                    "date": 1744248068551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,8 +201,9 @@\n     \r\n     # 计算动态仓位\r\n     position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n     current_price = close[-1]\r\n+    \r\n     return int(position_value / current_price / 100) * 100  # 整手数\r\n \r\n \r\n # 使用示例\r\n"
                },
                {
                    "date": 1744248481115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,10 +200,10 @@\n     risk_budget = account.cash['nav'] * context.risk_ratio\r\n     \r\n     # 计算动态仓位\r\n     position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n-    current_price = close[-1]\r\n-    \r\n+     current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+\r\n     return int(position_value / current_price / 100) * 100  # 整手数\r\n \r\n \r\n # 使用示例\r\n"
                },
                {
                    "date": 1744248509645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,211 @@\n+import pandas as pd\r\n+import numpy as np\r\n+\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+\r\n+\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, bars, period):\r\n+    \"\"\"\r\n+    计算平均真实波幅(ATR)\r\n+    :param data: DataFrame格式，包含high, low, close价格数据\r\n+    :param period: ATR计算周期\r\n+    :return: 最新ATR值\r\n+    \"\"\"\r\n+    # 获取数据滑窗\r\n+    data = context.data(symbol=bars[0]['symbol'], frequency='1d', count=15)\r\n+    high = data['high'].values\r\n+    low = data['low'].values\r\n+    close = data['close'].values\r\n+    \r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    # 计算ATR（简单移动平均）\r\n+    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n+    return atr[-1] if len(atr) > 0 else 0\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    \r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    # 计算ATR（简单移动平均）\r\n+    atr = np.convolve(tr, np.ones(context.atr_period)/context.atr_period, mode='valid')\r\n+    \r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    \r\n+    # 计算动态仓位\r\n+    position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+\r\n+    return int(position_value / current_price / 100) * 100  # 整手数\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744248563351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,213 @@\n+import pandas as pd\r\n+import numpy as np\r\n+\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+\r\n+\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, bars, period):\r\n+    \"\"\"\r\n+    计算平均真实波幅(ATR)\r\n+    :param data: DataFrame格式，包含high, low, close价格数据\r\n+    :param period: ATR计算周期\r\n+    :return: 最新ATR值\r\n+    \"\"\"\r\n+    # 获取数据滑窗\r\n+    data = context.data(symbol=bars[0]['symbol'], frequency='1d', count=15)\r\n+    high = data['high'].values\r\n+    low = data['low'].values\r\n+    close = data['close'].values\r\n+    \r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    # 计算ATR（简单移动平均）\r\n+    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n+    return atr[-1] if len(atr) > 0 else 0\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    \r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    # 计算ATR（简单移动平均）\r\n+    atr = np.convolve(tr, np.ones(context.atr_period)/context.atr_period, mode='valid')\r\n+    \r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = int(position_value / current_price)\r\n+    return (target_shares // 100) * 100  # 按整手数调整\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744249026816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,11 +191,12 @@\n             abs(high[i] - close[i-1]),\r\n             abs(low[i] - close[i-1])\r\n         )\r\n     \r\n-    # 计算ATR（简单移动平均）\r\n-    atr = np.convolve(tr, np.ones(context.atr_period)/context.atr_period, mode='valid')\r\n-    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n     # 获取账户风险预算\r\n     account = context.account()\r\n     risk_budget = account.cash['nav'] * context.risk_ratio\r\n     # 提取最新价格（标量值）\r\n@@ -209,427 +210,5 @@\n \r\n \r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-\r\n-\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, bars, period):\r\n-    \"\"\"\r\n-    计算平均真实波幅(ATR)\r\n-    :param data: DataFrame格式，包含high, low, close价格数据\r\n-    :param period: ATR计算周期\r\n-    :return: 最新ATR值\r\n-    \"\"\"\r\n-    # 获取数据滑窗\r\n-    data = context.data(symbol=bars[0]['symbol'], frequency='1d', count=15)\r\n-    high = data['high'].values\r\n-    low = data['low'].values\r\n-    close = data['close'].values\r\n-    \r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    # 计算ATR（简单移动平均）\r\n-    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n-    return atr[-1] if len(atr) > 0 else 0\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    \r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    # 计算ATR（简单移动平均）\r\n-    atr = np.convolve(tr, np.ones(context.atr_period)/context.atr_period, mode='valid')\r\n-    \r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    \r\n-    # 计算动态仓位\r\n-    position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-\r\n-    return int(position_value / current_price / 100) * 100  # 整手数\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-\r\n-\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, bars, period):\r\n-    \"\"\"\r\n-    计算平均真实波幅(ATR)\r\n-    :param data: DataFrame格式，包含high, low, close价格数据\r\n-    :param period: ATR计算周期\r\n-    :return: 最新ATR值\r\n-    \"\"\"\r\n-    # 获取数据滑窗\r\n-    data = context.data(symbol=bars[0]['symbol'], frequency='1d', count=15)\r\n-    high = data['high'].values\r\n-    low = data['low'].values\r\n-    close = data['close'].values\r\n-    \r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    # 计算ATR（简单移动平均）\r\n-    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n-    return atr[-1] if len(atr) > 0 else 0\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high'].values\r\n-    low = data['low'].values\r\n-    close = data['close'].values\r\n-    \r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    # 计算ATR（简单移动平均）\r\n-    atr = np.convolve(tr, np.ones(context.atr_period)/context.atr_period, mode='valid')\r\n-    \r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    \r\n-    # 计算动态仓位\r\n-    position_value = risk_budget / (atr * 1.5)  # 1.5倍ATR作为止损空间\r\n-     current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-\r\n-    return int(position_value / current_price / 100) * 100  # 整手数\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744249038722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,9 +181,9 @@\n                        fields='high,low,close')\r\n     high = data['high']\r\n     low = data['low']\r\n     close = data['close']\r\n-    \r\n+    prev_close = np.roll(close, shift=1)\r\n     # 计算真实波幅TR\r\n     tr = np.zeros(len(data))\r\n     for i in range(1, len(data)):\r\n         tr[i] = max(\r\n"
                }
            ],
            "date": 1744185176721,
            "name": "Commit-0",
            "content": "import pandas as pd\r\nimport numpy as np\r\n\r\n# 获取持仓\r\ndef get_position(symbol):\r\n    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n    if not position:  # 新增空值判断\r\n        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n        return\r\n    return position\r\n\r\n\r\n\r\n\r\n# 获取当前价格\r\ndef get_current_price(context, symbol):\r\n    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n    if len(current_data) == 0:\r\n        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n        return None\r\n    return current_data['close'].values[0]\r\n\r\n# 获取前一日收盘价\r\ndef get_previous_close_price(context, symbol):\r\n    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n    if len(previous_data) < 2:\r\n        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n        return None\r\n    return previous_data['close'].values[1]\r\n\r\n\r\n# 计算涨跌幅\r\ndef calculate_change_percentage(current_price, previous_close_price):\r\n    return (current_price - previous_close_price) / previous_close_price * 100\r\n\r\n\r\n\r\n#  获取涨停价\r\ndef get_limit_up_price(data, symbol):\r\n    \"\"\"\r\n    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n    :param data: 包含股票历史数据的 DataFrame\r\n    :param symbol: 股票代码\r\n    :return: 涨停价，如果数据不足则返回 None\r\n    \"\"\"\r\n    if len(data) >= 2:\r\n        # 索引 0 是当前数据，索引 1 是前一日数据\r\n        previous_close_price = data['close'].values[1]\r\n        # 判断股票类型，确定涨停幅度\r\n        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n            # 科创板和创业板股票，涨停幅度为 20%\r\n            limit_up_ratio = 0.2\r\n        elif 'ST' in symbol:\r\n            # ST 股票，涨停幅度为 5%\r\n            limit_up_ratio = 0.05\r\n        else:\r\n            # 普通股票，涨停幅度为 10%\r\n            limit_up_ratio = 0.1\r\n\r\n        # 计算涨停价\r\n        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n        # 按照实际情况取整，A股价格保留两位小数\r\n        limit_up_price = round(limit_up_price, 2)\r\n        return limit_up_price\r\n    else:\r\n        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n        return None\r\n\r\n\r\n\r\ndef eod_position_summary(context):\r\n    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n    account = context.account()\r\n    \r\n    # 获取持仓列表并过滤有效持仓\r\n    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n    \r\n    if not positions:\r\n        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n        return\r\n    \r\n    # 打印持仓明细表头\r\n    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n    \r\n    total_market_value = 0\r\n    total_profit_rate = 0\r\n    \r\n    for pos in positions:\r\n        # 获取关键字段（根据QMT接口规范调整字段名）\r\n        symbol = pos['symbol']                         # 标的代码\r\n        volume = int(pos['volume'])                    # 持仓数量\r\n        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n        market_value = volume * last_price             # 持仓市值\r\n        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n        \r\n        # 累计统计\r\n        total_market_value += market_value\r\n        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n        \r\n        # 格式化输出\r\n        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n\r\n    # 打印资产概况（网页3风险管理要求）\r\n    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\nprint('='*90)\r\n\r\n\r\n\r\ndef calculate_ATR(context, bars, period):\r\n    \"\"\"\r\n    计算平均真实波幅(ATR)\r\n    :param data: DataFrame格式，包含high, low, close价格数据\r\n    :param period: ATR计算周期\r\n    :return: 最新ATR值\r\n    \"\"\"\r\n    # 获取数据滑窗\r\n    data = context.data(symbol=bars[0]['symbol'], frequency='1d', count=15)\r\n    high = data['high'].values\r\n    low = data['low'].values\r\n    close = data['close'].values\r\n    \r\n    # 计算真实波幅TR\r\n    tr = np.zeros(len(data))\r\n    for i in range(1, len(data)):\r\n        tr[i] = max(\r\n            high[i] - low[i],\r\n            abs(high[i] - close[i-1]),\r\n            abs(low[i] - close[i-1])\r\n        )\r\n    \r\n    # 计算ATR（简单移动平均）\r\n    atr = np.convolve(tr, np.ones(period)/period, mode='valid')\r\n    return atr[-1] if len(atr) > 0 else 0\r\n\r\n\r\ndef EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n    alpha=2/(span+1)\r\n\r\n    Args:\r\n        S (np.ndarray): 时间序列\r\n        N (int): 指标周期\r\n\r\n    Returns:\r\n        np.ndarray: EMA\r\n    '''\r\n    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n\r\n#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\ndef MACD(CLOSE: np.ndarray,\r\n        SHORT: int = 6,\r\n        LONG: int = 38,\r\n        M: int = 6) -> tuple:\r\n    '''计算MACD\r\n    EMA的关系，S取120日\r\n\r\n    Args:\r\n        CLOSE (np.ndarray): 收盘价时间序列\r\n        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n        LONG (int, optional): ema 长周期. Defaults to 26.\r\n        M (int, optional): macd 平滑周期. Defaults to 9.\r\n\r\n    Returns:\r\n        tuple: _description_\r\n    '''\r\n    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n    DEA = EMA(DIF, M)\r\n    MACD = (DIF - DEA) * 2\r\n    return DIF, DEA, MACD\r\n\r\n\r\n# 使用示例\r\nif __name__ == \"__main__\":\r\n    None"
        }
    ]
}