{
    "sourceFile": "QTUtils.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1745720573711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745720580480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,410 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    # if trend_signal  :\r\n+    #     print(f\"[均线斜率向下] ：{trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    # if volume_signal  :\r\n+    #     print(f\"[量价背离] ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745720586498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n     context.trading_blocked[symbol] = {\r\n         'status': True,\r\n         'expire_time': context.now + datetime.timedelta(hours=hours)\r\n     }\r\n-    print(f\"====锁定交易并记录过期时间=========\" )\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n \r\n def unlock_trading(context, symbol):\r\n     \"\"\"解除交易锁\"\"\"\r\n     context.trading_blocked[symbol] = {\r\n"
                },
                {
                    "date": 1745721081556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -244,10 +244,10 @@\n     trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n                   (ma10[-1] < ma10[-5]) and \\\r\n                   (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n \r\n-    # if trend_signal  :\r\n-    #     print(f\"[均线斜率向下] ：{trend_signal} =========\")\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] ：{trend_signal} =========\")\r\n \r\n     # ===== 量价博弈层 =====\r\n     # 动态量能分析\r\n     vol_ma10 = data['volume'].rolling(10).mean().values\r\n@@ -319,9 +319,9 @@\n     context.trading_blocked[symbol] = {\r\n         'status': False,\r\n         'expire_time': None\r\n     }\r\n-    print(f\"====解锁交易并记录过期时间==========\" )\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n \r\n def algo(context):\r\n     ''' 尾盘调仓启动] '''\r\n     account = context.account()\r\n@@ -406,415 +406,5 @@\n \r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n     \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    # if trend_signal  :\r\n-    #     print(f\"[均线斜率向下] ：{trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    # if volume_signal  :\r\n-    #     print(f\"[量价背离] ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====锁定交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721099745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -245,9 +245,9 @@\n                   (ma10[-1] < ma10[-5]) and \\\r\n                   (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n \r\n     if trend_signal  :\r\n-        print(f\"[均线斜率向下] ：{trend_signal} =========\")\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n \r\n     # ===== 量价博弈层 =====\r\n     # 动态量能分析\r\n     vol_ma10 = data['volume'].rolling(10).mean().values\r\n"
                },
                {
                    "date": 1745721106931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,410 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721127016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,413 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721132425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,413 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721138308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,412 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721372588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -282,423 +282,14 @@\n \r\n     if pressure_signal  :\r\n         print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n \r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n \r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+pressure_signal\r\n \r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n \r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n-\r\n     # ===== 复合信号生成 =====\r\n     # 四重条件触发机制\r\n-\r\n     # 初始值 3\r\n     if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n         # 附加波动率过滤\r\n         atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n@@ -821,1238 +412,5 @@\n \r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n     \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    # if volume_signal  :\r\n-    #     print(f\"[量价背离] ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721379805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,416 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+\r\n+    pressure_signal = f\r\n+\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721390684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,416 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+#\r\n+    pressure_signal = False\r\n+\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721397853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,416 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    \r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+    #测试\r\n+    pressure_signal = False\r\n+\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 1:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721419850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -269,9 +269,11 @@\n     # 动量衰减条件\r\n     momentum_signal = (dif[-1] < dea[-1]) and \\\r\n                      (hist[-1] < hist[-3] * 0.7) and \\\r\n                      (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n+        if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n     # ===== 压力位博弈层 =====\r\n     # 动态压力线计算\r\n     resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n     # 压力位博弈条件\r\n@@ -412,1253 +414,5 @@\n \r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n     \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n-\r\n-#\r\n-    pressure_signal = False\r\n-\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n-\r\n-\r\n-    pressure_signal = f\r\n-\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-    \r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n-\r\n-\r\n-pressure_signal\r\n-\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721425050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,418 @@\n+import pandas as pd\r\n+import numpy as np\r\n+import datetime\r\n+from gm.api import *\r\n+import math\r\n+import datetime\r\n+# 获取持仓\r\n+def get_position(symbol):\r\n+    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n+    if not position:  # 新增空值判断\r\n+        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n+        return\r\n+    return position\r\n+\r\n+# 获取当前价格\r\n+def get_current_price(context, symbol):\r\n+    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n+    if len(current_data) == 0:\r\n+        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n+        return None\r\n+    return current_data['close'].values[0]\r\n+\r\n+# 获取前一日收盘价\r\n+def get_previous_close_price(context, symbol):\r\n+    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n+    if len(previous_data) < 2:\r\n+        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n+        return None\r\n+    return previous_data['close'].values[1]\r\n+\r\n+\r\n+# 计算涨跌幅\r\n+def calculate_change_percentage(current_price, previous_close_price):\r\n+    return (current_price - previous_close_price) / previous_close_price * 100\r\n+\r\n+\r\n+\r\n+#  获取涨停价\r\n+def get_limit_up_price(data, symbol):\r\n+    \"\"\"\r\n+    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n+    :param data: 包含股票历史数据的 DataFrame\r\n+    :param symbol: 股票代码\r\n+    :return: 涨停价，如果数据不足则返回 None\r\n+    \"\"\"\r\n+    if len(data) >= 2:\r\n+        # 索引 0 是当前数据，索引 1 是前一日数据\r\n+        previous_close_price = data['close'].values[1]\r\n+        # 判断股票类型，确定涨停幅度\r\n+        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n+            # 科创板和创业板股票，涨停幅度为 20%\r\n+            limit_up_ratio = 0.2\r\n+        elif 'ST' in symbol:\r\n+            # ST 股票，涨停幅度为 5%\r\n+            limit_up_ratio = 0.05\r\n+        else:\r\n+            # 普通股票，涨停幅度为 10%\r\n+            limit_up_ratio = 0.1\r\n+\r\n+        # 计算涨停价\r\n+        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n+        # 按照实际情况取整，A股价格保留两位小数\r\n+        limit_up_price = round(limit_up_price, 2)\r\n+        return limit_up_price\r\n+    else:\r\n+        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n+        return None\r\n+\r\n+\r\n+\r\n+def eod_position_summary(context):\r\n+    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n+    account = context.account()\r\n+    \r\n+    # 获取持仓列表并过滤有效持仓\r\n+    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n+    \r\n+    if not positions:\r\n+        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n+        return\r\n+    \r\n+    # 打印持仓明细表头\r\n+    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n+    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n+    \r\n+    total_market_value = 0\r\n+    total_profit_rate = 0\r\n+    \r\n+    for pos in positions:\r\n+        # 获取关键字段（根据QMT接口规范调整字段名）\r\n+        symbol = pos['symbol']                         # 标的代码\r\n+        volume = int(pos['volume'])                    # 持仓数量\r\n+        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n+        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n+        market_value = volume * last_price             # 持仓市值\r\n+        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n+        \r\n+        # 累计统计\r\n+        total_market_value += market_value\r\n+        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n+        \r\n+        # 格式化输出\r\n+        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n+            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n+\r\n+    # 打印资产概况（网页3风险管理要求）\r\n+    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n+    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n+    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n+print('='*90)\r\n+\r\n+\r\n+\r\n+def calculate_ATR(context, symbol):\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    # 获取ATR波动率\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n+                       fields='high,low,close')\r\n+    high = data['high']\r\n+    low = data['low']\r\n+    close = data['close']\r\n+    prev_close = np.roll(close, shift=1)\r\n+    # 计算真实波幅TR\r\n+    tr = np.zeros(len(data))\r\n+    for i in range(1, len(data)):\r\n+        tr[i] = max(\r\n+            high[i] - low[i],\r\n+            abs(high[i] - close[i-1]),\r\n+            abs(low[i] - close[i-1])\r\n+        )\r\n+    \r\n+    tr = np.maximum(high - low, \r\n+                   np.maximum(np.abs(high - prev_close), \r\n+                             np.abs(low - prev_close)))\r\n+    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n+    return atr\r\n+\r\n+\r\n+def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n+    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n+    alpha=2/(span+1)\r\n+\r\n+    Args:\r\n+        S (np.ndarray): 时间序列\r\n+        N (int): 指标周期\r\n+\r\n+    Returns:\r\n+        np.ndarray: EMA\r\n+    '''\r\n+    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n+\r\n+#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n+def MACD(CLOSE: np.ndarray,\r\n+        SHORT: int = 6,\r\n+        LONG: int = 38,\r\n+        M: int = 6) -> tuple:\r\n+    '''计算MACD\r\n+    EMA的关系，S取120日\r\n+\r\n+    Args:\r\n+        CLOSE (np.ndarray): 收盘价时间序列\r\n+        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n+        LONG (int, optional): ema 长周期. Defaults to 26.\r\n+        M (int, optional): macd 平滑周期. Defaults to 9.\r\n+\r\n+    Returns:\r\n+        tuple: _description_\r\n+    '''\r\n+    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n+    DEA = EMA(DIF, M)\r\n+    MACD = (DIF - DEA) * 2\r\n+    return DIF, DEA, MACD\r\n+\r\n+\r\n+def calculate_dynamic_position(context, symbol):\r\n+    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n+    \"\"\"动态仓位计算函数\"\"\"\r\n+    atr = calculate_ATR(context, symbol)\r\n+    # 获取账户风险预算\r\n+    account = context.account()\r\n+    risk_budget = account.cash['nav'] * context.risk_ratio\r\n+    # 提取最新价格（标量值）\r\n+    \r\n+    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n+    # 动态仓位计算（整手数处理）\r\n+    if atr == 0 or current_price == 0:  # 异常值保护\r\n+        return 0\r\n+    position_value = risk_budget / (atr * 1.5)\r\n+    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n+    return target_shares \r\n+\r\n+\r\n+\r\n+def check_timing_buy_signal(context, symbol):\r\n+    \"\"\"三重验证择时信号(买)\"\"\"\r\n+    # 1. 趋势判定（双均线）\r\n+    close = context.data(symbol=symbol, frequency=context.frequency, \r\n+                        count=context.trend_period, fields='close')['close']\r\n+    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n+    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n+    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n+    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n+    # 2. 量能突破\r\n+    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n+                      fields='volume')['volume']\r\n+    \r\n+    # 关键改进：数据长度与质量校验\r\n+    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n+        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n+        return False  # 或根据策略需求调整\r\n+\r\n+    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n+    \r\n+    # 3. MACD动量验证\r\n+    dif, dea, _ = MACD(close)\r\n+    # 数据长度校验（MACD默认需要26周期）\r\n+    if len(dif) < 2 or len(dea) < 2:\r\n+        print(f\"[警告] {symbol} MACD数据不足\")\r\n+        return False\r\n+    \r\n+    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n+    \r\n+    return trend_flag and volume_signal and macd_signal \r\n+\r\n+\r\n+def generate_sell_signal(context, symbol):\r\n+    \"\"\"四维量化卖出信号生成器\"\"\"\r\n+    # ===== 数据校验层 =====\r\n+    # 获取基础行情数据\r\n+    data = context.data(symbol, '1d', count=50, \r\n+                       fields=['close', 'high', 'low', 'volume'])\r\n+    \r\n+    flag = data['close'].values\r\n+    if len(flag) < 50:\r\n+        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n+        return False\r\n+    \r\n+    # ===== 趋势反转层 =====\r\n+    # 三重均线系统\r\n+    ma5 = data['close'].rolling(5).mean().values\r\n+    ma10 = data['close'].rolling(10).mean().values\r\n+    ma20 = data['close'].rolling(20).mean().values\r\n+    # 趋势反转条件# 均线斜率向下\r\n+    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n+                  (ma10[-1] < ma10[-5]) and \\\r\n+                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n+\r\n+    if trend_signal  :\r\n+        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n+\r\n+    # ===== 量价博弈层 =====\r\n+    # 动态量能分析\r\n+    vol_ma10 = data['volume'].rolling(10).mean().values\r\n+    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n+    \r\n+    # 量价背离检测\r\n+    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n+    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n+    volume_signal = (price_high and vol_low) or \\\r\n+                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n+\r\n+    if volume_signal  :\r\n+        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n+\r\n+\r\n+    # ===== 动量衰减层 =====\r\n+    # MACD动量系统\r\n+    dif, dea, hist = MACD(data['close'])\r\n+    # 动量衰减条件\r\n+    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n+                     (hist[-1] < hist[-3] * 0.7) and \\\r\n+                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n+    if momentum_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+    # ===== 压力位博弈层 =====\r\n+    # 动态压力线计算\r\n+    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n+    # 压力位博弈条件\r\n+    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n+    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n+                 (data['close'].iloc[-1] < resistance * 0.97)\r\n+    pressure_signal = price_near_resistance or false_break\r\n+\r\n+    if pressure_signal  :\r\n+        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+\r\n+    #测试\r\n+    pressure_signal = False\r\n+\r\n+\r\n+    # ===== 复合信号生成 =====\r\n+    # 四重条件触发机制\r\n+    # 初始值 3\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 1:\r\n+        # 附加波动率过滤\r\n+        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n+        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n+            return True\r\n+    return False\r\n+\r\n+def dynamic_resistance(high_series):\r\n+    \"\"\"动态压力线计算\"\"\"\r\n+    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n+\r\n+def check_trading_permission(context, symbol):\r\n+    \"\"\"添加类型校验\"\"\"\r\n+    status_data = context.trading_blocked.get(symbol, {})\r\n+    if isinstance(status_data, bool):\r\n+        # 兼容旧版布尔值初始化\r\n+        context.trading_blocked[symbol] = {\r\n+            'status': status_data,\r\n+            'expire_time': None\r\n+        }\r\n+    return not status_data.get('status', True)\r\n+\r\n+def lock_trading(context, symbol, hours=24):\r\n+    \"\"\"锁定交易并记录过期时间\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': True,\r\n+        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n+    }\r\n+    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n+\r\n+def unlock_trading(context, symbol):\r\n+    \"\"\"解除交易锁\"\"\"\r\n+    context.trading_blocked[symbol] = {\r\n+        'status': False,\r\n+        'expire_time': None\r\n+    }\r\n+    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n+\r\n+def algo(context):\r\n+    ''' 尾盘调仓启动] '''\r\n+    account = context.account()\r\n+    for symbol in context.all_symbols:\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 获取账户总资产\r\n+        available_cash = account.cash['nav']\r\n+        # 当日可交易总资金\r\n+        target_value = available_cash * context.total_cash_ratio \r\n+        # 当日交易股票数\r\n+        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n+        \r\n+        # 执行调仓\r\n+        delta = target_vol - current_vol\r\n+        \r\n+        if delta > 0:\r\n+            order_volume(symbol=symbol, \r\n+                        volume=delta,\r\n+                        side=OrderSide_Buy,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*1.005,  # 限价避免滑点\r\n+                        position_effect=PositionEffect_Open)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+        elif delta < 0:\r\n+            order_volume(symbol=symbol,\r\n+                        volume=abs(delta),\r\n+                        side=OrderSide_Sell,\r\n+                        order_type=OrderType_Limit,\r\n+                        price=current_price*0.995,\r\n+                        position_effect=PositionEffect_Close)\r\n+            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n+    \r\n+    # eod_position_summary(context)\r\n+\r\n+def daily_sell(context):\r\n+    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n+    account = context.account()\r\n+    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n+    \r\n+    for symbol in context.all_symbols:\r\n+        # 检查交易锁状态（网页4风控逻辑）\r\n+        if context.trading_blocked[symbol]['status']:\r\n+            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n+            continue\r\n+        # 获取当前持仓\r\n+        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n+        if position and len(position) > 0:\r\n+            current_vol = position[0]['volume']\r\n+            current_price = position[0]['price']\r\n+        else:\r\n+            current_vol = 0\r\n+            current_price = None  # 或使用行情接口获取最新价\r\n+            continue\r\n+            \r\n+        # 计算可卖数量（网页3仓位管理建议）\r\n+        current_vol = position[0]['volume']\r\n+        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n+        \r\n+        if sell_vol <= 0:\r\n+            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n+            continue\r\n+            \r\n+        # 执行限价卖出（网页6避免滑点建议）\r\n+        order_volume(symbol=symbol,\r\n+                    volume=sell_vol,\r\n+                    side=OrderSide_Sell,\r\n+                    order_type=OrderType_Limit,\r\n+                    price=current_price*0.995,  # 设置99.5%限价单\r\n+                    position_effect=PositionEffect_Close)\r\n+        \r\n+        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n+\r\n+\r\n+# 使用示例\r\n+if __name__ == \"__main__\":\r\n+    \r\n+    None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721448840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -270,9 +270,9 @@\n     momentum_signal = (dif[-1] < dea[-1]) and \\\r\n                      (hist[-1] < hist[-3] * 0.7) and \\\r\n                      (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n     if momentum_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+        print(f\"[动量衰减条件] momentum_signal = ：{pressure_signal} =========\")\r\n \r\n     # ===== 压力位博弈层 =====\r\n     # 动态压力线计算\r\n     resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n@@ -282,9 +282,9 @@\n                  (data['close'].iloc[-1] < resistance * 0.97)\r\n     pressure_signal = price_near_resistance or false_break\r\n \r\n     if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n+        print(f\"[压力位博弈层] pressure_signal = ：{pressure_signal} =========\")\r\n \r\n     #测试\r\n     pressure_signal = False\r\n \r\n@@ -414,423 +414,5 @@\n \r\n # 使用示例\r\n if __name__ == \"__main__\":\r\n     \r\n-    None\n-import pandas as pd\r\n-import numpy as np\r\n-import datetime\r\n-from gm.api import *\r\n-import math\r\n-import datetime\r\n-# 获取持仓\r\n-def get_position(symbol):\r\n-    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n-    if not position:  # 新增空值判断\r\n-        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n-        return\r\n-    return position\r\n-\r\n-# 获取当前价格\r\n-def get_current_price(context, symbol):\r\n-    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n-    if len(current_data) == 0:\r\n-        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n-        return None\r\n-    return current_data['close'].values[0]\r\n-\r\n-# 获取前一日收盘价\r\n-def get_previous_close_price(context, symbol):\r\n-    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n-    if len(previous_data) < 2:\r\n-        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n-        return None\r\n-    return previous_data['close'].values[1]\r\n-\r\n-\r\n-# 计算涨跌幅\r\n-def calculate_change_percentage(current_price, previous_close_price):\r\n-    return (current_price - previous_close_price) / previous_close_price * 100\r\n-\r\n-\r\n-\r\n-#  获取涨停价\r\n-def get_limit_up_price(data, symbol):\r\n-    \"\"\"\r\n-    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n-    :param data: 包含股票历史数据的 DataFrame\r\n-    :param symbol: 股票代码\r\n-    :return: 涨停价，如果数据不足则返回 None\r\n-    \"\"\"\r\n-    if len(data) >= 2:\r\n-        # 索引 0 是当前数据，索引 1 是前一日数据\r\n-        previous_close_price = data['close'].values[1]\r\n-        # 判断股票类型，确定涨停幅度\r\n-        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n-            # 科创板和创业板股票，涨停幅度为 20%\r\n-            limit_up_ratio = 0.2\r\n-        elif 'ST' in symbol:\r\n-            # ST 股票，涨停幅度为 5%\r\n-            limit_up_ratio = 0.05\r\n-        else:\r\n-            # 普通股票，涨停幅度为 10%\r\n-            limit_up_ratio = 0.1\r\n-\r\n-        # 计算涨停价\r\n-        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n-        # 按照实际情况取整，A股价格保留两位小数\r\n-        limit_up_price = round(limit_up_price, 2)\r\n-        return limit_up_price\r\n-    else:\r\n-        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n-        return None\r\n-\r\n-\r\n-\r\n-def eod_position_summary(context):\r\n-    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n-    account = context.account()\r\n-    \r\n-    # 获取持仓列表并过滤有效持仓\r\n-    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n-    \r\n-    if not positions:\r\n-        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n-        return\r\n-    \r\n-    # 打印持仓明细表头\r\n-    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n-    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n-    \r\n-    total_market_value = 0\r\n-    total_profit_rate = 0\r\n-    \r\n-    for pos in positions:\r\n-        # 获取关键字段（根据QMT接口规范调整字段名）\r\n-        symbol = pos['symbol']                         # 标的代码\r\n-        volume = int(pos['volume'])                    # 持仓数量\r\n-        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n-        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n-        market_value = volume * last_price             # 持仓市值\r\n-        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n-        \r\n-        # 累计统计\r\n-        total_market_value += market_value\r\n-        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n-        \r\n-        # 格式化输出\r\n-        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n-            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n-\r\n-    # 打印资产概况（网页3风险管理要求）\r\n-    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n-    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n-    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n-\r\n-\r\n-\r\n-def calculate_ATR(context, symbol):\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    # 获取ATR波动率\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n-                       fields='high,low,close')\r\n-    high = data['high']\r\n-    low = data['low']\r\n-    close = data['close']\r\n-    prev_close = np.roll(close, shift=1)\r\n-    # 计算真实波幅TR\r\n-    tr = np.zeros(len(data))\r\n-    for i in range(1, len(data)):\r\n-        tr[i] = max(\r\n-            high[i] - low[i],\r\n-            abs(high[i] - close[i-1]),\r\n-            abs(low[i] - close[i-1])\r\n-        )\r\n-    \r\n-    tr = np.maximum(high - low, \r\n-                   np.maximum(np.abs(high - prev_close), \r\n-                             np.abs(low - prev_close)))\r\n-    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n-    return atr\r\n-\r\n-\r\n-def EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n-    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n-    alpha=2/(span+1)\r\n-\r\n-    Args:\r\n-        S (np.ndarray): 时间序列\r\n-        N (int): 指标周期\r\n-\r\n-    Returns:\r\n-        np.ndarray: EMA\r\n-    '''\r\n-    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n-\r\n-#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\n-def MACD(CLOSE: np.ndarray,\r\n-        SHORT: int = 6,\r\n-        LONG: int = 38,\r\n-        M: int = 6) -> tuple:\r\n-    '''计算MACD\r\n-    EMA的关系，S取120日\r\n-\r\n-    Args:\r\n-        CLOSE (np.ndarray): 收盘价时间序列\r\n-        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n-        LONG (int, optional): ema 长周期. Defaults to 26.\r\n-        M (int, optional): macd 平滑周期. Defaults to 9.\r\n-\r\n-    Returns:\r\n-        tuple: _description_\r\n-    '''\r\n-    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n-    DEA = EMA(DIF, M)\r\n-    MACD = (DIF - DEA) * 2\r\n-    return DIF, DEA, MACD\r\n-\r\n-\r\n-def calculate_dynamic_position(context, symbol):\r\n-    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n-    \"\"\"动态仓位计算函数\"\"\"\r\n-    atr = calculate_ATR(context, symbol)\r\n-    # 获取账户风险预算\r\n-    account = context.account()\r\n-    risk_budget = account.cash['nav'] * context.risk_ratio\r\n-    # 提取最新价格（标量值）\r\n-    \r\n-    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n-    # 动态仓位计算（整手数处理）\r\n-    if atr == 0 or current_price == 0:  # 异常值保护\r\n-        return 0\r\n-    position_value = risk_budget / (atr * 1.5)\r\n-    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n-    return target_shares \r\n-\r\n-\r\n-\r\n-def check_timing_buy_signal(context, symbol):\r\n-    \"\"\"三重验证择时信号(买)\"\"\"\r\n-    # 1. 趋势判定（双均线）\r\n-    close = context.data(symbol=symbol, frequency=context.frequency, \r\n-                        count=context.trend_period, fields='close')['close']\r\n-    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n-    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n-    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n-    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n-    # 2. 量能突破\r\n-    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n-                      fields='volume')['volume']\r\n-    \r\n-    # 关键改进：数据长度与质量校验\r\n-    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n-        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n-        return False  # 或根据策略需求调整\r\n-\r\n-    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n-    \r\n-    # 3. MACD动量验证\r\n-    dif, dea, _ = MACD(close)\r\n-    # 数据长度校验（MACD默认需要26周期）\r\n-    if len(dif) < 2 or len(dea) < 2:\r\n-        print(f\"[警告] {symbol} MACD数据不足\")\r\n-        return False\r\n-    \r\n-    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n-    \r\n-    return trend_flag and volume_signal and macd_signal \r\n-\r\n-\r\n-def generate_sell_signal(context, symbol):\r\n-    \"\"\"四维量化卖出信号生成器\"\"\"\r\n-    # ===== 数据校验层 =====\r\n-    # 获取基础行情数据\r\n-    data = context.data(symbol, '1d', count=50, \r\n-                       fields=['close', 'high', 'low', 'volume'])\r\n-    \r\n-    flag = data['close'].values\r\n-    if len(flag) < 50:\r\n-        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n-        return False\r\n-    \r\n-    # ===== 趋势反转层 =====\r\n-    # 三重均线系统\r\n-    ma5 = data['close'].rolling(5).mean().values\r\n-    ma10 = data['close'].rolling(10).mean().values\r\n-    ma20 = data['close'].rolling(20).mean().values\r\n-    # 趋势反转条件# 均线斜率向下\r\n-    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n-                  (ma10[-1] < ma10[-5]) and \\\r\n-                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n-\r\n-    if trend_signal  :\r\n-        print(f\"[均线斜率向下] trend_signal = {trend_signal} =========\")\r\n-\r\n-    # ===== 量价博弈层 =====\r\n-    # 动态量能分析\r\n-    vol_ma10 = data['volume'].rolling(10).mean().values\r\n-    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n-    \r\n-    # 量价背离检测\r\n-    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n-    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n-    volume_signal = (price_high and vol_low) or \\\r\n-                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n-\r\n-    if volume_signal  :\r\n-        print(f\"[量价背离] volume_signal = ：{volume_signal} =========\")\r\n-\r\n-\r\n-    # ===== 动量衰减层 =====\r\n-    # MACD动量系统\r\n-    dif, dea, hist = MACD(data['close'])\r\n-    # 动量衰减条件\r\n-    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n-                     (hist[-1] < hist[-3] * 0.7) and \\\r\n-                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n-        if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n-\r\n-    # ===== 压力位博弈层 =====\r\n-    # 动态压力线计算\r\n-    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n-    # 压力位博弈条件\r\n-    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n-    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n-                 (data['close'].iloc[-1] < resistance * 0.97)\r\n-    pressure_signal = price_near_resistance or false_break\r\n-\r\n-    if pressure_signal  :\r\n-        print(f\"[量价背离] pressure_signal = ：{pressure_signal} =========\")\r\n-\r\n-    #测试\r\n-    pressure_signal = False\r\n-\r\n-\r\n-    # ===== 复合信号生成 =====\r\n-    # 四重条件触发机制\r\n-    # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 1:\r\n-        # 附加波动率过滤\r\n-        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n-        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n-            return True\r\n-    return False\r\n-\r\n-def dynamic_resistance(high_series):\r\n-    \"\"\"动态压力线计算\"\"\"\r\n-    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n-\r\n-def check_trading_permission(context, symbol):\r\n-    \"\"\"添加类型校验\"\"\"\r\n-    status_data = context.trading_blocked.get(symbol, {})\r\n-    if isinstance(status_data, bool):\r\n-        # 兼容旧版布尔值初始化\r\n-        context.trading_blocked[symbol] = {\r\n-            'status': status_data,\r\n-            'expire_time': None\r\n-        }\r\n-    return not status_data.get('status', True)\r\n-\r\n-def lock_trading(context, symbol, hours=24):\r\n-    \"\"\"锁定交易并记录过期时间\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': True,\r\n-        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n-    }\r\n-    print(f\"====lock_trading锁定交易并记录过期时间=========\" )\r\n-\r\n-def unlock_trading(context, symbol):\r\n-    \"\"\"解除交易锁\"\"\"\r\n-    context.trading_blocked[symbol] = {\r\n-        'status': False,\r\n-        'expire_time': None\r\n-    }\r\n-    print(f\"====unlock_trading解锁交易并记录过期时间==========\" )\r\n-\r\n-def algo(context):\r\n-    ''' 尾盘调仓启动] '''\r\n-    account = context.account()\r\n-    for symbol in context.all_symbols:\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 获取账户总资产\r\n-        available_cash = account.cash['nav']\r\n-        # 当日可交易总资金\r\n-        target_value = available_cash * context.total_cash_ratio \r\n-        # 当日交易股票数\r\n-        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n-        \r\n-        # 执行调仓\r\n-        delta = target_vol - current_vol\r\n-        \r\n-        if delta > 0:\r\n-            order_volume(symbol=symbol, \r\n-                        volume=delta,\r\n-                        side=OrderSide_Buy,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*1.005,  # 限价避免滑点\r\n-                        position_effect=PositionEffect_Open)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-        elif delta < 0:\r\n-            order_volume(symbol=symbol,\r\n-                        volume=abs(delta),\r\n-                        side=OrderSide_Sell,\r\n-                        order_type=OrderType_Limit,\r\n-                        price=current_price*0.995,\r\n-                        position_effect=PositionEffect_Close)\r\n-            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n-    \r\n-    # eod_position_summary(context)\r\n-\r\n-def daily_sell(context):\r\n-    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n-    account = context.account()\r\n-    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n-    \r\n-    for symbol in context.all_symbols:\r\n-        # 检查交易锁状态（网页4风控逻辑）\r\n-        if context.trading_blocked[symbol]['status']:\r\n-            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n-            continue\r\n-        # 获取当前持仓\r\n-        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n-        if position and len(position) > 0:\r\n-            current_vol = position[0]['volume']\r\n-            current_price = position[0]['price']\r\n-        else:\r\n-            current_vol = 0\r\n-            current_price = None  # 或使用行情接口获取最新价\r\n-            continue\r\n-            \r\n-        # 计算可卖数量（网页3仓位管理建议）\r\n-        current_vol = position[0]['volume']\r\n-        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n-        \r\n-        if sell_vol <= 0:\r\n-            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n-            continue\r\n-            \r\n-        # 执行限价卖出（网页6避免滑点建议）\r\n-        order_volume(symbol=symbol,\r\n-                    volume=sell_vol,\r\n-                    side=OrderSide_Sell,\r\n-                    order_type=OrderType_Limit,\r\n-                    price=current_price*0.995,  # 设置99.5%限价单\r\n-                    position_effect=PositionEffect_Close)\r\n-        \r\n-        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n-\r\n-\r\n-# 使用示例\r\n-if __name__ == \"__main__\":\r\n-    \r\n     None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745721458738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,9 +291,9 @@\n \r\n     # ===== 复合信号生成 =====\r\n     # 四重条件触发机制\r\n     # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 1:\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n         # 附加波动率过滤\r\n         atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n         if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n             return True\r\n"
                },
                {
                    "date": 1745721505662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -270,9 +270,9 @@\n     momentum_signal = (dif[-1] < dea[-1]) and \\\r\n                      (hist[-1] < hist[-3] * 0.7) and \\\r\n                      (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n     if momentum_signal  :\r\n-        print(f\"[动量衰减条件] momentum_signal = ：{pressure_signal} =========\")\r\n+        print(f\"[动量衰减条件] momentum_signal = ：{momentum_signal} =========\")\r\n \r\n     # ===== 压力位博弈层 =====\r\n     # 动态压力线计算\r\n     resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n"
                },
                {
                    "date": 1745721730892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -284,12 +284,9 @@\n \r\n     if pressure_signal  :\r\n         print(f\"[压力位博弈层] pressure_signal = ：{pressure_signal} =========\")\r\n \r\n-    #测试\r\n-    pressure_signal = False\r\n \r\n-\r\n     # ===== 复合信号生成 =====\r\n     # 四重条件触发机制\r\n     # 初始值 3\r\n     if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n"
                },
                {
                    "date": 1745722475547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -288,9 +288,9 @@\n \r\n     # ===== 复合信号生成 =====\r\n     # 四重条件触发机制\r\n     # 初始值 3\r\n-    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n+    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 1:\r\n         # 附加波动率过滤\r\n         atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n         if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n             return True\r\n"
                },
                {
                    "date": 1745724192066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -106,9 +106,9 @@\n     # 打印资产概况（网页3风险管理要求）\r\n     print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n     print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n     print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\n-print('='*90)\r\n+    print('='*90)\r\n \r\n \r\n \r\n def calculate_ATR(context, symbol):\r\n"
                }
            ],
            "date": 1745720573711,
            "name": "Commit-0",
            "content": "import pandas as pd\r\nimport numpy as np\r\nimport datetime\r\nfrom gm.api import *\r\nimport math\r\nimport datetime\r\n# 获取持仓\r\ndef get_position(symbol):\r\n    position = list(filter(lambda x:x['symbol']==symbol,get_position()))\r\n    if not position:  # 新增空值判断\r\n        print(f\"{symbol} 无持仓，跳过交易逻辑\")\r\n        return\r\n    return position\r\n\r\n# 获取当前价格\r\ndef get_current_price(context, symbol):\r\n    current_data = context.data(symbol=symbol, frequency=context.frequency, count=1, fields='close')\r\n    if len(current_data) == 0:\r\n        print(f\"未获取到 {symbol} 当前价格数据。\")\r\n        return None\r\n    return current_data['close'].values[0]\r\n\r\n# 获取前一日收盘价\r\ndef get_previous_close_price(context, symbol):\r\n    previous_data = context.data(symbol=symbol, frequency='1d', count=2, fields='close')\r\n    if len(previous_data) < 2:\r\n        print(f\"未获取到 {symbol} 前一日收盘价数据。\")\r\n        return None\r\n    return previous_data['close'].values[1]\r\n\r\n\r\n# 计算涨跌幅\r\ndef calculate_change_percentage(current_price, previous_close_price):\r\n    return (current_price - previous_close_price) / previous_close_price * 100\r\n\r\n\r\n\r\n#  获取涨停价\r\ndef get_limit_up_price(data, symbol):\r\n    \"\"\"\r\n    此函数用于根据给定的股票数据和股票代码计算涨停价\r\n    :param data: 包含股票历史数据的 DataFrame\r\n    :param symbol: 股票代码\r\n    :return: 涨停价，如果数据不足则返回 None\r\n    \"\"\"\r\n    if len(data) >= 2:\r\n        # 索引 0 是当前数据，索引 1 是前一日数据\r\n        previous_close_price = data['close'].values[1]\r\n        # 判断股票类型，确定涨停幅度\r\n        if symbol.startswith('SHSE.688') or (symbol.startswith('SZSE.30') and 'SZSE.300' not in symbol):\r\n            # 科创板和创业板股票，涨停幅度为 20%\r\n            limit_up_ratio = 0.2\r\n        elif 'ST' in symbol:\r\n            # ST 股票，涨停幅度为 5%\r\n            limit_up_ratio = 0.05\r\n        else:\r\n            # 普通股票，涨停幅度为 10%\r\n            limit_up_ratio = 0.1\r\n\r\n        # 计算涨停价\r\n        limit_up_price = previous_close_price * (1 + limit_up_ratio)\r\n        # 按照实际情况取整，A股价格保留两位小数\r\n        limit_up_price = round(limit_up_price, 2)\r\n        return limit_up_price\r\n    else:\r\n        print(f\"未获取到 {symbol} 足够的历史数据。\")\r\n        return None\r\n\r\n\r\n\r\ndef eod_position_summary(context):\r\n    \"\"\"打印尾盘持仓明细及资产概况\"\"\"\r\n    account = context.account()\r\n    \r\n    # 获取持仓列表并过滤有效持仓\r\n    positions = [pos for pos in account.positions() if pos['volume'] > 0]\r\n    \r\n    if not positions:\r\n        print(f\"{context.now.strftime('%H:%M')} 无持仓\")\r\n        return\r\n    \r\n    # 打印持仓明细表头\r\n    print(f\"\\n{'='*30} 尾盘持仓明细 {context.now.strftime('%Y-%m-%d %H:%M')} {'='*30}\")\r\n    print(f\"{'标的代码':<7} | {'持仓数量':>7} | {'持仓成本':>6} | {'最新价':>6} | {'持仓市值':>7} | {'盈亏比例':>7}\")\r\n    \r\n    total_market_value = 0\r\n    total_profit_rate = 0\r\n    \r\n    for pos in positions:\r\n        # 获取关键字段（根据QMT接口规范调整字段名）\r\n        symbol = pos['symbol']                         # 标的代码\r\n        volume = int(pos['volume'])                    # 持仓数量\r\n        cost_price = pos['vwap']                       # 持仓均价[2](@ref)\r\n        last_price = pos['price']                      # 最新行情价[2](@ref)\r\n        market_value = volume * last_price             # 持仓市值\r\n        profit_rate = (last_price - cost_price)/cost_price if cost_price else 0  # 盈亏比例\r\n        \r\n        # 累计统计\r\n        total_market_value += market_value\r\n        total_profit_rate += profit_rate * (market_value/total_market_value if total_market_value else 0)\r\n        \r\n        # 格式化输出\r\n        print(f\"{symbol:<10} | {volume:>10} | {cost_price:>10.2f} | {last_price:>10.2f} | \"\r\n            f\"{market_value:>10.2f} | {profit_rate:>+8.2%}\")\r\n\r\n    # 打印资产概况（网页3风险管理要求）\r\n    print(f\"\\n[资产概况] 总市值={total_market_value:.2f}元 | 组合收益率={total_profit_rate:.2%}\")\r\n    print(f\"[资金状态] 可用资金={account.cash['available']:.2f}元 | 总资产={account.cash['nav']:.2f}元\")\r\n    print(f\"[风险提示] 单票最大亏损={min((p['price']-p['vwap'])/p['vwap'] for p in positions):.2%}\")\r\nprint('='*90)\r\n\r\n\r\n\r\ndef calculate_ATR(context, symbol):\r\n    \"\"\"动态仓位计算函数\"\"\"\r\n    # 获取ATR波动率\r\n    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, \r\n                       fields='high,low,close')\r\n    high = data['high']\r\n    low = data['low']\r\n    close = data['close']\r\n    prev_close = np.roll(close, shift=1)\r\n    # 计算真实波幅TR\r\n    tr = np.zeros(len(data))\r\n    for i in range(1, len(data)):\r\n        tr[i] = max(\r\n            high[i] - low[i],\r\n            abs(high[i] - close[i-1]),\r\n            abs(low[i] - close[i-1])\r\n        )\r\n    \r\n    tr = np.maximum(high - low, \r\n                   np.maximum(np.abs(high - prev_close), \r\n                             np.abs(low - prev_close)))\r\n    atr = np.mean(tr[-context.atr_period:]).item()  # 标量化处理\r\n    return atr\r\n\r\n\r\ndef EMA(S: np.ndarray, N: int) -> np.ndarray:\r\n    '''指数移动平均,为了精度 S>4*N  EMA至少需要120周期     \r\n    alpha=2/(span+1)\r\n\r\n    Args:\r\n        S (np.ndarray): 时间序列\r\n        N (int): 指标周期\r\n\r\n    Returns:\r\n        np.ndarray: EMA\r\n    '''\r\n    return pd.Series(S).ewm(span=N, adjust=False).mean().values\r\n\r\n#原始值：SHORT: int = 12,LONG: int = 26,M: int = 9\r\ndef MACD(CLOSE: np.ndarray,\r\n        SHORT: int = 6,\r\n        LONG: int = 38,\r\n        M: int = 6) -> tuple:\r\n    '''计算MACD\r\n    EMA的关系，S取120日\r\n\r\n    Args:\r\n        CLOSE (np.ndarray): 收盘价时间序列\r\n        SHORT (int, optional): ema 短周期. Defaults to 12.\r\n        LONG (int, optional): ema 长周期. Defaults to 26.\r\n        M (int, optional): macd 平滑周期. Defaults to 9.\r\n\r\n    Returns:\r\n        tuple: _description_\r\n    '''\r\n    DIF = EMA(CLOSE, SHORT) - EMA(CLOSE, LONG)\r\n    DEA = EMA(DIF, M)\r\n    MACD = (DIF - DEA) * 2\r\n    return DIF, DEA, MACD\r\n\r\n\r\ndef calculate_dynamic_position(context, symbol):\r\n    data = context.data(symbol=symbol, frequency='1d', count=context.atr_period+1, fields='high,low,close')\r\n    \"\"\"动态仓位计算函数\"\"\"\r\n    atr = calculate_ATR(context, symbol)\r\n    # 获取账户风险预算\r\n    account = context.account()\r\n    risk_budget = account.cash['nav'] * context.risk_ratio\r\n    # 提取最新价格（标量值）\r\n    \r\n    current_price = data['close'].values[-1]  # 明确取最后一个元素\r\n    # 动态仓位计算（整手数处理）\r\n    if atr == 0 or current_price == 0:  # 异常值保护\r\n        return 0\r\n    position_value = risk_budget / (atr * 1.5)\r\n    target_shares = (int(position_value / current_price)) / 100 * 100 # 按整手数调整\r\n    return target_shares \r\n\r\n\r\n\r\ndef check_timing_buy_signal(context, symbol):\r\n    \"\"\"三重验证择时信号(买)\"\"\"\r\n    # 1. 趋势判定（双均线）\r\n    close = context.data(symbol=symbol, frequency=context.frequency, \r\n                        count=context.trend_period, fields='close')['close']\r\n    ma5 = pd.Series(close).rolling(5).mean().values[-1]\r\n    ma10 = pd.Series(close).rolling(10).mean().values[-1]\r\n    # trend_flag = ma5 > ma10 and ma5 > ma10 * 1.01  # 5日线上穿20日线1%\r\n    trend_flag = ma5 > ma10   # 5日线上穿10日线\r\n    # 2. 量能突破\r\n    vol = context.data(symbol=symbol, frequency='1d', count=5, \r\n                      fields='volume')['volume']\r\n    \r\n    # 关键改进：数据长度与质量校验\r\n    if len(vol) < 4:  # 至少需要4日数据（当前日+前3日）\r\n        print(f\"[警告] {symbol} 成交量数据不足4日（实际：{len(vol)}）\")\r\n        return False  # 或根据策略需求调整\r\n\r\n    volume_signal = vol.iloc[-1] > np.mean(vol.iloc[:-1]) * context.volume_ratio\r\n    \r\n    # 3. MACD动量验证\r\n    dif, dea, _ = MACD(close)\r\n    # 数据长度校验（MACD默认需要26周期）\r\n    if len(dif) < 2 or len(dea) < 2:\r\n        print(f\"[警告] {symbol} MACD数据不足\")\r\n        return False\r\n    \r\n    macd_signal = dif[-1] > dea[-1] and dif[-2] < dea[-2]  # 金叉确认\r\n    \r\n    return trend_flag and volume_signal and macd_signal \r\n\r\n\r\ndef generate_sell_signal(context, symbol):\r\n    \"\"\"四维量化卖出信号生成器\"\"\"\r\n    # ===== 数据校验层 =====\r\n    # 获取基础行情数据\r\n    data = context.data(symbol, '1d', count=50, \r\n                       fields=['close', 'high', 'low', 'volume'])\r\n    \r\n    flag = data['close'].values\r\n    if len(flag) < 50:\r\n        print(f\"[风控] {symbol} 历史数据不足50日\")\r\n        return False\r\n    \r\n    # ===== 趋势反转层 =====\r\n    # 三重均线系统\r\n    ma5 = data['close'].rolling(5).mean().values\r\n    ma10 = data['close'].rolling(10).mean().values\r\n    ma20 = data['close'].rolling(20).mean().values\r\n    # 趋势反转条件# 均线斜率向下\r\n    trend_signal = (ma5[-1] < ma10[-1]) and \\\r\n                  (ma10[-1] < ma10[-5]) and \\\r\n                  (data['close'].iloc[-1] < ma20[-1] * 0.97)  # 收盘价破55日线3%\r\n\r\n    # if trend_signal  :\r\n    #     print(f\"[均线斜率向下] ：{trend_signal} =========\")\r\n\r\n    # ===== 量价博弈层 =====\r\n    # 动态量能分析\r\n    vol_ma10 = data['volume'].rolling(10).mean().values\r\n    current_vol = data['volume'].iloc[-1]  # 明确使用位置索引\r\n    \r\n    # 量价背离检测\r\n    price_high = data['close'].iloc[-1] > data['close'].iloc[-5:-1].max()\r\n    vol_low = current_vol < vol_ma10[-1] * 0.8\r\n    volume_signal = (price_high and vol_low) or \\\r\n                   (current_vol > vol_ma10[-1] * 2.5 and data['close'].iloc[-1] < data['close'].iloc[-2])\r\n\r\n    # if volume_signal  :\r\n    #     print(f\"[量价背离] ：{volume_signal} =========\")\r\n\r\n\r\n    # ===== 动量衰减层 =====\r\n    # MACD动量系统\r\n    dif, dea, hist = MACD(data['close'])\r\n    # 动量衰减条件\r\n    momentum_signal = (dif[-1] < dea[-1]) and \\\r\n                     (hist[-1] < hist[-3] * 0.7) and \\\r\n                     (dif[-1] < np.mean(dif[-10:]) * 0.9)\r\n    \r\n    # ===== 压力位博弈层 =====\r\n    # 动态压力线计算\r\n    resistance = dynamic_resistance(data['high'])  # 实现动态压力函数\r\n    # 压力位博弈条件\r\n    price_near_resistance = data['close'].iloc[-1] > resistance * 0.985\r\n    false_break = (data['close'].iloc[-3] > resistance) and \\\r\n                 (data['close'].iloc[-1] < resistance * 0.97)\r\n    pressure_signal = price_near_resistance or false_break\r\n\r\n    # ===== 复合信号生成 =====\r\n    # 四重条件触发机制\r\n\r\n    # 初始值 3\r\n    if (trend_signal + volume_signal + momentum_signal + pressure_signal) >= 2:\r\n        # 附加波动率过滤\r\n        atr = calculate_ATR(context, symbol)  # 实现ATR计算\r\n        if (data['close'].iloc[-1] - data['close'].iloc[-5])/data['close'].iloc[-5] < atr * 2:\r\n            return True\r\n    return False\r\n\r\ndef dynamic_resistance(high_series):\r\n    \"\"\"动态压力线计算\"\"\"\r\n    return high_series.rolling(30).max().shift(1).iloc[-1] * 0.987\r\n\r\ndef check_trading_permission(context, symbol):\r\n    \"\"\"添加类型校验\"\"\"\r\n    status_data = context.trading_blocked.get(symbol, {})\r\n    if isinstance(status_data, bool):\r\n        # 兼容旧版布尔值初始化\r\n        context.trading_blocked[symbol] = {\r\n            'status': status_data,\r\n            'expire_time': None\r\n        }\r\n    return not status_data.get('status', True)\r\n\r\ndef lock_trading(context, symbol, hours=24):\r\n    \"\"\"锁定交易并记录过期时间\"\"\"\r\n    context.trading_blocked[symbol] = {\r\n        'status': True,\r\n        'expire_time': context.now + datetime.timedelta(hours=hours)\r\n    }\r\n    print(f\"====锁定交易并记录过期时间=========\" )\r\n\r\ndef unlock_trading(context, symbol):\r\n    \"\"\"解除交易锁\"\"\"\r\n    context.trading_blocked[symbol] = {\r\n        'status': False,\r\n        'expire_time': None\r\n    }\r\n    print(f\"====锁定交易并记录过期时间==========\" )\r\n\r\ndef algo(context):\r\n    ''' 尾盘调仓启动] '''\r\n    account = context.account()\r\n    for symbol in context.all_symbols:\r\n        # 获取当前持仓\r\n        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n        if position and len(position) > 0:\r\n            current_vol = position[0]['volume']\r\n            current_price = position[0]['price']\r\n        else:\r\n            current_vol = 0\r\n            current_price = None  # 或使用行情接口获取最新价\r\n            continue\r\n            \r\n        # 获取账户总资产\r\n        available_cash = account.cash['nav']\r\n        # 当日可交易总资金\r\n        target_value = available_cash * context.total_cash_ratio \r\n        # 当日交易股票数\r\n        target_vol = math.ceil((target_value / current_price) / 200) * 200  # 整手数\r\n        \r\n        # 执行调仓\r\n        delta = target_vol - current_vol\r\n        \r\n        if delta > 0:\r\n            order_volume(symbol=symbol, \r\n                        volume=delta,\r\n                        side=OrderSide_Buy,\r\n                        order_type=OrderType_Limit,\r\n                        price=current_price*1.005,  # 限价避免滑点\r\n                        position_effect=PositionEffect_Open)\r\n            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时买入{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n        elif delta < 0:\r\n            order_volume(symbol=symbol,\r\n                        volume=abs(delta),\r\n                        side=OrderSide_Sell,\r\n                        order_type=OrderType_Limit,\r\n                        price=current_price*0.995,\r\n                        position_effect=PositionEffect_Close)\r\n            print(f\"\\n===== [尾盘调仓启动]{symbol} 定时卖出{target_vol}股 | 限价{current_price*0.995:.2f}\" )\r\n    \r\n    # eod_position_summary(context)\r\n\r\ndef daily_sell(context):\r\n    \"\"\"每日10:01卖出持仓的1/5\"\"\"\r\n    account = context.account()\r\n    print(f\"\\n===== {context.now} 定时卖出启动 =====\")\r\n    \r\n    for symbol in context.all_symbols:\r\n        # 检查交易锁状态（网页4风控逻辑）\r\n        if context.trading_blocked[symbol]['status']:\r\n            print(f\"{symbol} 交易锁生效中，跳过卖出\")\r\n            continue\r\n        # 获取当前持仓\r\n        position = account.positions(symbol=symbol, side=PositionSide_Long)\r\n        if position and len(position) > 0:\r\n            current_vol = position[0]['volume']\r\n            current_price = position[0]['price']\r\n        else:\r\n            current_vol = 0\r\n            current_price = None  # 或使用行情接口获取最新价\r\n            continue\r\n            \r\n        # 计算可卖数量（网页3仓位管理建议）\r\n        current_vol = position[0]['volume']\r\n        sell_vol = math.ceil(current_vol / 10 / 100) * 100  # 取整手数（A股100股整数倍）\r\n        \r\n        if sell_vol <= 0:\r\n            print(f\"{symbol} 持仓不足5手，无法执行1/5卖出\")\r\n            continue\r\n            \r\n        # 执行限价卖出（网页6避免滑点建议）\r\n        order_volume(symbol=symbol,\r\n                    volume=sell_vol,\r\n                    side=OrderSide_Sell,\r\n                    order_type=OrderType_Limit,\r\n                    price=current_price*0.995,  # 设置99.5%限价单\r\n                    position_effect=PositionEffect_Close)\r\n        \r\n        print(f\"{symbol} 定时卖出{sell_vol}股 | 限价{current_price*0.995:.2f}\")\r\n\r\n\r\n# 使用示例\r\nif __name__ == \"__main__\":\r\n    \r\n    None"
        }
    ]
}